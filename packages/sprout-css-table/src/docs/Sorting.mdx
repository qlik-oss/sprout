import { Meta, Canvas, Controls } from "@storybook/addon-docs/blocks";
import * as ListStories from "./ListTable.stories";

<Meta title="Docs/Sorting" />

# Sorting

Sorting is enabled by default and works out of the box using `alphanumeric` sorting.
By default sorting is done on client side. If you want to do sorting on server side, you need to set `sortingMode` Table prop to `"server"`.

## Client side

### Default sorting

If we want to set an initial sorting order, this can be done by passing `defaultSorting` as prop to the table

```tsx
import { type SortingState } from "@tanstack/react-table";
import { Table } from "@qlik/sprout-css-table";

const defaultSorting: SortingState = [
  {
    id: "firstName",
    desc: true,
  },
];

return <Table rows={rows} columns={columns} defaultSorting={defaultSorting} />;
```

### Controlled sorting

The contolled sorting is useful in scenarios where we would like to control sorting state externally, and execute some code when sorting state changes.
Example: table with data that is taken from paginated API with sorting on server side.

Use `sorting` table prop to control the state of the sorting.

Use `onSortingChange` function as table prop to listen to changes in sorting state

```tsx
import { useState } from "react";
import { type SortingState } from "@tanstack/react-table";
import { Table } from "@qlik/sprout-css-table";

function ComponentUsingTable() {
  const [sortingState, setSortingState] = useState<SortingState>();

  const onSortingChange = (sorting: SortingState) => {
    setSortingState(sorting);
    // do something else
  };

  return <Table rows={rows} columns={columns} sorting={sortingState} onSortingChange={onSortingChange} />;
}
```

### Custom sorting

The default sorting function for all columns is set to `alphanumeric` sorting.  
However, it can be useful to define the exact sorting function that you want to use for a specific column, especially if any of your data is nullable or not a standard data type.

You can determine a custom sorting function on a per-column basis using the `sortComparator` column option that accepts determined sorting functions :

- `alphanumeric` (default)
- `datetime`
- `text`
- `basic`

```tsx
// If you want to sort by date for example
export const entityCustomSorting: ColumnDef<Entity>[] = [
  {
    field: "modified",
    headerName: "Modified",
    sortComparator: "datetime",
  },
];
```

You can also define your own custom sorting function.  
Every sorting function receives 2 rows and a column ID and are expected to compare the two rows using the column ID to return `-1`, `0`, or `1` in ascending order.

```tsx
// If you want to sort by date for example
const sortByDate = (a: Row<Entity>, b: Row<Entity>, columnId: string) =>
  new Date(a.modified).getTime() - new Date(b.modified).getTime();

export const entityCustomSorting: ColumnDef<Entity>[] = [
  {
    field: "modified",
    headerName: "Modified",
    sortComparator: sortByDate,
  },
];
```

## Disable sorting

If sorting is disabled for a column, sort actions will not be available in header menu

### For all table columns

The `disableColumnSorting` table prop allows to disable sorting for all table columns

```tsx
import { Table } from "@qlik/sprout-css-table";

return <Table rows={rows} columns={columns} disableColumnSorting />;
```

### For some columns

The `sortable` column property allows to disable sorting for specific column.

```tsx
const columns = [
  { field: "name", headerName: "Product Name", width: 200 },
  { field: "description", headerName: "Description", width: 300, sortable: false },
];
```

## Sort object

By default the sort order cycles through ascending, descending, and unsorted when clicking on the column header or using the header menu.
If you have built a custom cell by using `renderCell` column property, the chance is high that you are using an object as `field`.
In this case order can be broken. You need in this case to provide a `valueGetter` that return a string. For the enduser to have a good user experience the string should be the one that the user see in the cell.

```diff
{
  headerName: 'Address',
-  field: 'address',
+  valueGetter: (row) => `${row.address.street} ${row.address.code} ${row.address.city}`,
  renderCell: (params) => (
    <div>
      <div>{params.row.address.street}</div>
      <div>{params.row.address.code} {params.row.address.city}</div>
    </div>
  ),
}
```

## Server side sorting

When working with large datasets or paginated APIs, sorting is often handled on the server side to optimize performance.
To enable server side sorting, set the `sortingMode` table prop to `"server"`.

Then you have to setup a `useEffect` in your component to listen to changes in sorting state and fetch sorted data from the server accordingly.

```tsx
function MyTableComponent() {
  const [data, setData] = useState(() => makeEntity(50));
  const [sorting, setSorting] = useState<SortingState>([]);

  useEffect(() => {
    // Fetch sorted data from server based on current sorting state
    fetchSortedData(sorting).then((sortedData) => {
      setData(sortedData);
    });
  }, [sorting]);

  return <Table rows={data} columns={columns} sorting={sorting} onSortingChange={setSorting} sortingMode="server" />;
}
```

## API

<Controls of={ListStories.ServerSideSorting} />
